# Indigo Stack Migration Guide

This guide provides step-by-step instructions for migrating existing SwiftUI projects to the Indigo Stack, which uses Tuist for project management, TCA (The Composable Architecture), and a modern modular structure.

## Prerequisites

- Existing SwiftUI project (iOS/macOS)
- Xcode 16+ compatibility
- Basic understanding of Swift Package Manager
- Access to project build settings and configurations

## Project Structure Overview

The Indigo Stack follows a clean three-layer architecture:

```md
ProjectRoot/
├── App/ # Main application target
│ ├── Project.swift # App target configuration
│ ├── Sources/ # App-specific code
│ ├── Resources/ # App assets and resources
│ ├── Tests/ # App tests
│ ├── ios.entitlements # iOS entitlements
│ └── mac.entitlements # macOS entitlements
├── Core/ # Business logic & external dependencies
│ ├── Project.swift # Core framework configuration
│ ├── Sources/ # Core business logic
│ └── Tests/ # Core tests
├── Components/ # Reusable UI components
│ ├── Project.swift # Components framework configuration
│ ├── Sources/ # SwiftUI components
│ └── Tests/ # Component tests
├── Configs/ # Build configurations
│ ├── Debug.xcconfig # Debug settings
│ └── Release.xcconfig # Release settings
├── Tuist/ # Tuist helpers
│ └── ProjectDescriptionHelpers/
│ └── Project+Templates.swift
├── Tuist.swift # Tuist configuration
├── Workspace.swift # Workspace definition
├── Package.swift # Dependencies
└── mise.toml # Tuist version management
```

## Migration Steps

### Step 1: Configure Project Settings

**Important**: Before proceeding with the migration, you must update the project configuration values in `Tuist/ProjectDescriptionHelpers/Config.swift`:

```swift
import ProjectDescription

public let teamReverseDomain = "com.yourcompany"  // Replace with your reverse domain
public let appName: TargetReference = "YourApp"   // Replace with your app name
```

These values will be used throughout the project configuration to set bundle identifiers, target names, and other project-specific settings.

### Step 2: Install Tuist and Setup Tools

```bash
# Install Mise (Tuist version manager)
curl https://mise.jdx.dev/install.sh | sh

# Create mise.toml file
echo '[tools]
tuist = "4.54.3"' > mise.toml

# Install Tuist
mise install
```

### Step 3: Extract Dependencies from Existing Project

From your existing Xcode project, extract the following information:

#### A. External Dependencies

- Open your existing project in Xcode
- Navigate to Package Manager dependencies
- List all external Swift packages
- Note their versions and URLs

#### B. Build Settings to Extract

Look for these settings in your existing project:

- `MARKETING_VERSION`
- `CURRENT_PROJECT_VERSION`
- `BUNDLE_IDENTIFIER`
- `DEPLOYMENT_TARGET` (iOS/macOS)
- `CODE_SIGN_ENTITLEMENTS`
- `OTHER_LDFLAGS`
- Custom build settings
- Info.plist modifications

#### C. Assets and Resources

- Identify all asset catalogs (.xcassets)
- Locate resource files (images, data files, etc.)
- Note any custom Info.plist entries
- Collect entitlements files

### Step 4: Create Core Tuist Configuration Files

#### A. Create `Tuist.swift`

```swift
import ProjectDescription

let config = Config(project: .tuist())
```

#### B. Create `Package.swift`

```swift
// swift-tools-version: 6.0
@preconcurrency import PackageDescription

#if TUIST
  import ProjectDescription

  let packageSettings = PackageSettings(
    productTypes: [:]
  )
#endif

let package = Package(
  name: "YourAppName",
  dependencies: [
    // Add your extracted dependencies here
    // Example:
    // .package(url: "https://github.com/pointfreeco/swift-composable-architecture", from: "1.17.0"),
  ]
)
```

#### C. Create `Workspace.swift`

```swift
import ProjectDescription

let workspace = Workspace(
  name: "YourAppName",
  projects: [
    "App",
    "Core",
    "Components",
    "Indigo",
    // Add your feature modules here:
    // "UserProfile",
    // "ShoppingCart",
    // "Settings",
  ],
  generationOptions: .options(
    autogeneratedWorkspaceSchemes: .disabled,
    lastXcodeUpgradeCheck: Version(16, 3, 0)
  )
)
```

### Step 5: Create Build Configuration Files

#### A. Create `Configs/Debug.xcconfig`

```config
ALWAYS_SEARCH_USER_PATHS=NO
CLANG_ANALYZER_NONNULL=YES
CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION=YES_AGGRESSIVE
CLANG_CXX_LANGUAGE_STANDARD=gnu++14
CLANG_CXX_LIBRARY=libc++
CLANG_ENABLE_MODULES=YES
CLANG_ENABLE_OBJC_ARC=YES
CLANG_ENABLE_OBJC_WEAK=YES
CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING=YES
CLANG_WARN_BOOL_CONVERSION=YES
CLANG_WARN_COMMA=YES
CLANG_WARN_CONSTANT_CONVERSION=YES
CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS=YES
CLANG_WARN_DIRECT_OBJC_ISA_USAGE=YES_ERROR
CLANG_WARN_DOCUMENTATION_COMMENTS=YES
CLANG_WARN_EMPTY_BODY=YES
CLANG_WARN_ENUM_CONVERSION=YES
CLANG_WARN_INFINITE_RECURSION=YES
CLANG_WARN_INT_CONVERSION=YES
CLANG_WARN_NON_LITERAL_NULL_CONVERSION=YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF=YES
CLANG_WARN_OBJC_LITERAL_CONVERSION=YES
CLANG_WARN_OBJC_ROOT_CLASS=YES_ERROR
CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER=YES
CLANG_WARN_RANGE_LOOP_ANALYSIS=YES
CLANG_WARN_STRICT_PROTOTYPES=YES
CLANG_WARN_SUSPICIOUS_MOVE=YES
CLANG_WARN_UNGUARDED_AVAILABILITY=YES_AGGRESSIVE
CLANG_WARN_UNREACHABLE_CODE=YES
CLANG_WARN__DUPLICATE_METHOD_MATCH=YES
COPY_PHASE_STRIP=NO
ENABLE_STRICT_OBJC_MSGSEND=YES
GCC_C_LANGUAGE_STANDARD=gnu11
GCC_NO_COMMON_BLOCKS=YES
GCC_WARN_64_TO_32_BIT_CONVERSION=YES
GCC_WARN_ABOUT_RETURN_TYPE=YES_ERROR
GCC_WARN_UNDECLARED_SELECTOR=YES
GCC_WARN_UNINITIALIZED_AUTOS=YES_AGGRESSIVE
GCC_WARN_UNUSED_FUNCTION=YES
GCC_WARN_UNUSED_VARIABLE=YES
IPHONEOS_DEPLOYMENT_TARGET=18.0
MTL_FAST_MATH=YES
SDKROOT=iphoneos
SWIFT_ACTIVE_COMPILATION_CONDITIONS=DEBUG
SWIFT_OPTIMIZATION_LEVEL=-Onone
ONLY_ACTIVE_ARCH=YES
DEBUG_INFORMATION_FORMAT=dwarf
ENABLE_NS_ASSERTIONS=YES
ENABLE_TESTABILITY=YES
GCC_DYNAMIC_NO_PIC=NO
GCC_OPTIMIZATION_LEVEL=0
GCC_PREPROCESSOR_DEFINITIONS=DEBUG=1
MTL_ENABLE_DEBUG_INFO=INCLUDE_SOURCE
DISPLAY_NAME="YourApp Dev"
```

#### B. Create `Configs/Release.xcconfig`

```config
ALWAYS_SEARCH_USER_PATHS=NO
CLANG_ANALYZER_NONNULL=YES
CLANG_ANALYZER_NUMBER_OBJECT_CONVERSION=YES_AGGRESSIVE
CLANG_CXX_LANGUAGE_STANDARD=gnu++14
CLANG_CXX_LIBRARY=libc++
CLANG_ENABLE_MODULES=YES
CLANG_ENABLE_OBJC_ARC=YES
CLANG_ENABLE_OBJC_WEAK=YES
CLANG_WARN_BLOCK_CAPTURE_AUTORELEASING=YES
CLANG_WARN_BOOL_CONVERSION=YES
CLANG_WARN_COMMA=YES
CLANG_WARN_CONSTANT_CONVERSION=YES
CLANG_WARN_DEPRECATED_OBJC_IMPLEMENTATIONS=YES
CLANG_WARN_DIRECT_OBJC_ISA_USAGE=YES_ERROR
CLANG_WARN_DOCUMENTATION_COMMENTS=YES
CLANG_WARN_EMPTY_BODY=YES
CLANG_WARN_ENUM_CONVERSION=YES
CLANG_WARN_INFINITE_RECURSION=YES
CLANG_WARN_INT_CONVERSION=YES
CLANG_WARN_NON_LITERAL_NULL_CONVERSION=YES
CLANG_WARN_OBJC_IMPLICIT_RETAIN_SELF=YES
CLANG_WARN_OBJC_LITERAL_CONVERSION=YES
CLANG_WARN_OBJC_ROOT_CLASS=YES_ERROR
CLANG_WARN_QUOTED_INCLUDE_IN_FRAMEWORK_HEADER=YES
CLANG_WARN_RANGE_LOOP_ANALYSIS=YES
CLANG_WARN_STRICT_PROTOTYPES=YES
CLANG_WARN_SUSPICIOUS_MOVE=YES
CLANG_WARN_UNGUARDED_AVAILABILITY=YES_AGGRESSIVE
CLANG_WARN_UNREACHABLE_CODE=YES
CLANG_WARN__DUPLICATE_METHOD_MATCH=YES
COPY_PHASE_STRIP=NO
ENABLE_STRICT_OBJC_MSGSEND=YES
GCC_C_LANGUAGE_STANDARD=gnu11
GCC_NO_COMMON_BLOCKS=YES
GCC_WARN_64_TO_32_BIT_CONVERSION=YES
GCC_WARN_ABOUT_RETURN_TYPE=YES_ERROR
GCC_WARN_UNDECLARED_SELECTOR=YES
GCC_WARN_UNINITIALIZED_AUTOS=YES_AGGRESSIVE
GCC_WARN_UNUSED_FUNCTION=YES
GCC_WARN_UNUSED_VARIABLE=YES
IPHONEOS_DEPLOYMENT_TARGET=18.0
MTL_FAST_MATH=YES
SDKROOT=iphoneos
SWIFT_COMPILATION_MODE=wholemodule
SWIFT_OPTIMIZATION_LEVEL=-O
VALIDATE_PRODUCT=YES
DEBUG_INFORMATION_FORMAT=dwarf-with-dsym
ENABLE_NS_ASSERTIONS=NO
MTL_ENABLE_DEBUG_INFO=NO
DISPLAY_NAME="YourApp"
```

### Step 6: Create Tuist Helper Templates

#### Create `Tuist/ProjectDescriptionHelpers/Project+Templates.swift`

```swift
import ProjectDescription

extension Project {
  public static func framework(
    name: String,
    reverseDomain: String,
    tca: Bool = false,
    dependencies: [TargetDependency] = []
  ) -> Project {
    .init(
      name: name,
      settings: .settings(
        base: [
          "ENABLE_USER_SCRIPT_SANDBOXING": "YES",
          "ENABLE_MODULE_VERIFIER": "YES",
          "MODULE_VERIFIER_SUPPORTED_LANGUAGE_STANDARDS": "gnu11 gnu++14",
        ]
      ),
      targets: [
        .target(
          name: name,
          destinations: [.iPad, .iPhone, .mac],
          product: .framework,
          bundleId: "\(reverseDomain).\(name)",
          deploymentTargets: .multiplatform(iOS: "18.0", macOS: "15.0"),
          sources: ["Sources/**"],
          dependencies: (tca
            ? [.project(target: "Indigo", path: .relativeToRoot("Indigo"))] : [])
            + dependencies
        ),
        .target(
          name: "\(name)Tests",
          destinations: [.iPad, .iPhone, .mac],
          product: .unitTests,
          bundleId: "\(reverseDomain).\(name)Tests",
          sources: ["Tests/**"]
        ),
      ]
    )
  }
}
```

### Step 7: Create Module Projects

#### A. Create `App/Project.swift`

```swift
import ProjectDescription

let project = Project(
  name: "App",
  settings: .settings(
    base: [
      "ENABLE_USER_SCRIPT_SANDBOXING": "YES",
      "ASSETCATALOG_COMPILER_GENERATE_SWIFT_ASSET_SYMBOL_EXTENSIONS": "YES",
    ],
    configurations: [
      .debug(name: "Debug", xcconfig: .relativeToRoot("Configs/Debug.xcconfig")),
      .release(name: "Release", xcconfig: .relativeToRoot("Configs/Release.xcconfig")),
    ]
  ),
  targets: [
    .target(
      name: "YourAppName",
      destinations: [.iPad, .iPhone, .mac],
      product: .app,
      bundleId: "com.yourcompany.YourAppName",
      deploymentTargets: .multiplatform(iOS: "18.0", macOS: "15.0"),
      infoPlist: .extendingDefault(
        with: [
          "UILaunchScreen": [
            "UIColorName": "",
            "UIImageName": "",
          ]
        ]
      ),
      sources: ["Sources/**"],
      resources: ["Resources/**"],
      dependencies: [
        .project(target: "Core", path: .relativeToRoot("Core")),
        .project(target: "Components", path: .relativeToRoot("Components")),
        // Add your feature module dependencies here:
        // .project(target: "UserProfile", path: .relativeToRoot("UserProfile")),
        // .project(target: "ShoppingCart", path: .relativeToRoot("ShoppingCart")),
        // .project(target: "Settings", path: .relativeToRoot("Settings")),
      ],
      settings: .settings(
        base: [
          "OTHER_LDFLAGS": ["$(inherited)", "-ObjC"],
          "CODE_SIGN_ENTITLEMENTS[sdk=macosx*]": .string("mac.entitlements"),
          "CODE_SIGN_ENTITLEMENTS[sdk=iphoneos*]": .string("ios.entitlements"),
          "CODE_SIGN_ENTITLEMENTS[sdk=iphonesimulator*]": .string("ios.entitlements"),
          "INFOPLIST_KEY_CFBundleDisplayName": "$(DISPLAY_NAME)",
        ]
      )
    )
  ],
  schemes: [
    .scheme(
      name: "YourAppName Debug",
      shared: true,
      buildAction: .buildAction(targets: ["YourAppName"]),
      runAction: .runAction(
        configuration: "Debug",
        executable: "YourAppName"
      ),
      archiveAction: .archiveAction(configuration: "Debug"),
      profileAction: .profileAction(
        configuration: "Debug",
        executable: "YourAppName"
      ),
      analyzeAction: .analyzeAction(configuration: "Debug")
    ),
    .scheme(
      name: "YourAppName Release",
      shared: true,
      buildAction: .buildAction(targets: ["YourAppName"]),
      runAction: .runAction(
        configuration: "Release",
        executable: "YourAppName"
      ),
      archiveAction: .archiveAction(configuration: "Release"),
      profileAction: .profileAction(
        configuration: "Release",
        executable: "YourAppName"
      ),
      analyzeAction: .analyzeAction(configuration: "Release")
    ),
  ]
)
```

#### B. Create `Core/Project.swift`

```swift
import ProjectDescription
import ProjectDescriptionHelpers

let project = Project.framework(
  name: "Core",
  reverseDomain: "net.4rays"
)
```

#### C. Create `Components/Project.swift`

```swift
import ProjectDescription
import ProjectDescriptionHelpers

let project = Project.framework(
  name: "Components",
  reverseDomain: "net.4rays"
)
```

#### D. Create Feature Modules (Optional)

> **Note**: FeatureA and FeatureB are example feature modules provided as reference implementations. In your actual project, you should create feature modules that correspond to your application's specific functionality (e.g., UserProfile, ShoppingCart, Settings, etc.).

For TCA-based feature modules, create individual feature projects based on your app's requirements:

**Example: UserProfile/Project.swift:**

```swift
import ProjectDescription
import ProjectDescriptionHelpers

let project = Project.framework(
  name: "UserProfile",
  reverseDomain: "com.yourcompany",
  tca: true,
)
```

**Example: ShoppingCart/Project.swift:**

```swift
import ProjectDescription
import ProjectDescriptionHelpers

let project = Project.framework(
  name: "ShoppingCart",
  reverseDomain: "com.yourcompany",
  tca: true,
)
```

### Step 7a: Feature Module Naming Conventions

When creating TCA-based feature modules, follow these naming conventions:

#### Reducer Naming

- Use `{ModuleName}Feature` pattern for reducers
- Examples:
  - `UserProfileFeature` for UserProfile module
  - `ShoppingCartFeature` for ShoppingCart module
  - `SettingsFeature` for Settings module

#### View Naming

- Use `{ModuleName}View` pattern for main views
- Examples:
  - `UserProfileView` for UserProfile module
  - `ShoppingCartView` for ShoppingCart module
  - `SettingsView` for Settings module

#### Example Feature Structure

Replace `UserProfile` with your actual feature name:

```swift
// UserProfile/Sources/Feature.swift
@Reducer
public struct UserProfileFeature {
  // State, Action, and reducer body implementation
}

public struct UserProfileView: View {
  @Bindable public var store: StoreOf<UserProfileFeature>

  public var body: some View {
    // View implementation
  }
}
```

### Step 8: Code Migration Strategy

#### A. Initial Code Placement

For simplicity, initially place ALL existing code in the `App/Sources/` directory:

- Copy all Swift files from your existing project
- Maintain existing folder structure within `App/Sources/`
- Keep existing import statements intact

#### B. Resource Migration

1. Copy `Assets.xcassets` to `App/Resources/`
2. Move other resources to `App/Resources/`
3. Copy entitlements files to `App/` directory
4. Update resource references in code if needed

#### C. Test Migration

1. Copy existing test files to `App/Tests/`
2. Update test target references
3. Fix any import issues

### Step 9: Generate and Verify

```bash
# Install dependencies
tuist install

# Generate Xcode project
tuist generate

# Open the generated workspace
open App.xcworkspace
```

### Step 10: Gradual Refactoring (Post-Migration)

Once the project builds successfully, gradually refactor:

#### A. Extract Reusable Components

- Move generic SwiftUI views to `Components/Sources/`
- Ensure components have no external dependencies
- Update imports in App module

#### B. Extract Business Logic

- Move data models to `Core/Sources/`
- Move API clients to `Core/Sources/`
- Move business logic to `Core/Sources/`
- Add necessary dependencies to `Core/Project.swift`

#### C. Update Dependencies

- Remove dependencies from App target
- Add dependencies to appropriate modules
- Update imports throughout codebase

### Step 11: Common Issues and Solutions

#### A. Import Issues

- **Problem**: Missing imports after migration
- **Solution**: Add explicit imports for frameworks used
- **Example**: Add `import SwiftUI` to views

#### B. Resource Access

- **Problem**: Resources not found
- **Solution**: Update bundle access or use Tuist's generated resource accessors

#### C. Build Settings

- **Problem**: Custom build settings not applied
- **Solution**: Add them to appropriate `.xcconfig` files or Project.swift

#### D. Code Signing

- **Problem**: Entitlements not applied
- **Solution**: Ensure entitlements files are in correct location and referenced in Project.swift

### Step 12: Verification Checklist

- [ ] Project builds successfully
- [ ] All resources are accessible
- [ ] Tests run without issues
- [ ] App launches on simulator/device
- [ ] All existing functionality works
- [ ] Code signing works for distribution
- [ ] All schemes build correctly

### Step 13: Advanced Configuration

#### A. Custom Build Phases

Add custom build phases in Project.swift:

```swift
.target(
  name: "YourApp",
  // ... other configuration
  scripts: [
    .pre(
      script: "echo 'Custom build phase'",
      name: "Custom Pre-build"
    )
  ]
)
```

#### B. Multiple Platforms

Configure different settings per platform:

```swift
settings: .settings(
  base: [
    "CODE_SIGN_ENTITLEMENTS[sdk=macosx*]": .string("mac.entitlements"),
    "CODE_SIGN_ENTITLEMENTS[sdk=iphoneos*]": .string("ios.entitlements"),
  ]
)
```

## Best Practices for AI Agents

1. **Incremental Migration**: Start with basic structure, then refactor gradually
2. **Backup Original**: Always keep original project as reference
3. **Test Frequently**: Generate and test after each major change
4. **Follow Naming Conventions**: Use consistent naming for modules and targets
5. **Documentation**: Keep migration notes for future reference
6. **Dependencies**: Be careful with external dependencies - prefer explicit over implicit
7. **Resource Management**: Verify all resources are accessible after migration

## Common Pitfalls to Avoid

- Don't change too much at once
- Don't forget to update bundle identifiers
- Don't mix module responsibilities initially
- Don't ignore build warnings
- Don't forget to update Info.plist entries

## Migration Commands Reference

```bash
# Setup
curl https://mise.jdx.dev/install.sh | sh
mise install

# Development workflow
tuist install          # Install dependencies
tuist generate         # Generate Xcode project
tuist clean           # Clean generated files
tuist edit            # Edit Tuist configuration

# Troubleshooting
tuist graph           # Visualize project structure
tuist build           # Build without Xcode
```

This migration guide provides a systematic approach for AI agents to successfully migrate SwiftUI projects to the Indigo Stack architecture while maintaining functionality and enabling future modular development.
